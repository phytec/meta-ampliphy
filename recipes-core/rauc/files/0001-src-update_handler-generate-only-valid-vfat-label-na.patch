From 71c9c58f78feb1f310cc14f275367a485e6968df Mon Sep 17 00:00:00 2001
From: Enrico Joerns <ejo@pengutronix.de>
Date: Fri, 16 Apr 2021 14:53:24 +0200
Subject: [PATCH] src/update_handler: generate only valid vfat label names

Depending on the vfat implementation, vfat labels can be interpreted
quite strictly, following the original specification.

This is why mkfs.vfat introduced more stricter sanity checks on label
names with dosfstoolfs v4.2.

See also dosfstools commit 40da1b2c ("fatlabel: Implement proper checks
when setting new label") for this:
https://github.com/dosfstools/dosfstools/commit/40da1b2c0129124f70fc0ec74363c699a3a479f8

Labels created so far by RAUC did not follow the FAT specification, too.
This becomes actually more critical as recent mkfs.vfat now refuses vfat
creation on the target.

This commit introduce vfat_label_generator() function that turns the
slot name into a valid FAT label.

This also makes the prior string length check superfluous which was
incorrect anyway as it tested for 16 instead of allowed 11 characters.

Signed-off-by: Enrico Joerns <ejo@pengutronix.de>
---
 src/update_handler.c | 51 ++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 47 insertions(+), 4 deletions(-)

diff --git a/src/update_handler.c b/src/update_handler.c
index 9e39a87..9227069 100644
--- a/src/update_handler.c
+++ b/src/update_handler.c
@@ -547,6 +547,51 @@ out:
 	return res;
 }
 
+/**
+ * Create valid / safe vfat label names.
+ *
+ * mkfs.vfat label requirements:
+ *
+ * | mkfs.fat: Warning: lowercase labels might not work properly on some systems
+ * | mkfs.vfat: Labels with characters *?.,;:/\|+=<>[]" are not allowed
+ * | mkfs.vfat: Label can be no longer than 11 characters
+ *
+ * This cuts input at 11 characters, makes all characters uppercase and
+ * replaces all invalid characters by '_' (underscore)
+ *
+ * @param name input name to create vfat label from
+ * @return newly-allocated string to be used as "-n" argument for mkfs.vfat
+ */
+static gchar* vfat_label_generator(const gchar *name)
+{
+	gchar *label_name;
+	const gchar *invalid_chars = "*?.,;:/\\|+=<>[]\"";
+
+	g_return_val_if_fail(name, NULL);
+
+	/* limit label length to 11 characters */
+	if (strlen(name) > 11)
+		label_name = g_strndup(name, 11);
+	else
+		label_name = g_strdup(name);
+
+	for (gchar *c = label_name; *c != '\0'; c++) {
+		/* make chars uppercase */
+		if (g_ascii_islower(*c))
+			*c = g_ascii_toupper(*c);
+		/* replace invalid chars */
+		for (size_t i = 0; i < strlen(invalid_chars); i++) {
+			g_message("r: %c", invalid_chars[i]);
+			if (*c == invalid_chars[i]) {
+				*c = '_';
+				break;
+			}
+		}
+	}
+
+	return label_name;
+}
+
 static gboolean vfat_format_slot(RaucSlot *dest_slot, GError **error)
 {
 	g_autoptr(GSubprocess) sproc = NULL;
@@ -555,10 +600,8 @@ static gboolean vfat_format_slot(RaucSlot *dest_slot, GError **error)
 	g_autoptr(GPtrArray) args = g_ptr_array_new_full(4, g_free);
 
 	g_ptr_array_add(args, g_strdup("mkfs.vfat"));
-	if (strlen(dest_slot->name) <= 16) {
-		g_ptr_array_add(args, g_strdup("-n"));
-		g_ptr_array_add(args, g_strdup(dest_slot->name));
-	}
+	g_ptr_array_add(args, g_strdup("-n"));
+	g_ptr_array_add(args, vfat_label_generator(dest_slot->name));
 	g_ptr_array_add(args, g_strdup(dest_slot->device));
 	g_ptr_array_add(args, NULL);
 
-- 
2.32.0

